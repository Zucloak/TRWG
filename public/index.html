<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Recorder | Refactored</title>
    <link rel="icon" href="favicon.ico">
    <style>
        :root {
            --bg-color: #f9fafb;
            --card-bg: #ffffff;
            --text-color: #374151;
            --text-light: #6b7280;
            --border-color: #d1d5db;
            --blue: #2563eb;
            --blue-dark: #1d4ed8;
            --red: #dc2626;
            --red-dark: #b91c1c;
            --green: #16a34a;
            --green-dark: #15803d;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2rem 1rem;
        }
        .container { max-width: 800px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 2rem; }
        h1 { font-size: 2rem; font-weight: 300; margin: 0 0 0.5rem 0; }
        h2 { font-size: 1.25rem; font-weight: 500; margin-bottom: 1rem; }
        h3 { font-size: 0.9rem; font-weight: 500; margin-bottom: 0.75rem; color: var(--text-light); }
        main { background-color: var(--card-bg); border-radius: 0.75rem; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); padding: 1.5rem; }
        .controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; margin-bottom: 1.5rem; }
        button { padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; color: white; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; gap: 0.5rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #startRecording { background-color: var(--blue); }
        #startRecording:not(:disabled):hover { background-color: var(--blue-dark); }
        #stopRecording { background-color: var(--red); }
        #stopRecording:not(:disabled):hover { background-color: var(--red-dark); }
        #downloadBtn { background-color: var(--green); }
        #downloadBtn:not(:disabled):hover { background-color: var(--green-dark); }
        #statusIndicator { display: flex; align-items: center; justify-content: center; margin-bottom: 1.5rem; color: var(--text-light); }
        #statusIcon { width: 1.5rem; height: 1.5rem; margin-right: 0.75rem; display: flex; align-items: center; justify-content: center; }
        .loader { border: 4px solid #e5e7eb; border-top-color: var(--blue); border-radius: 50%; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .recording-pulse { width: 1rem !important; height: 1rem !important; background-color: var(--red); border-radius: 50%; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .icon-symbol { font-size: 1.5rem; }
        .preview-container { background-color: #f3f4f6; aspect-ratio: 16 / 9; border-radius: 0.5rem; display: flex; align-items: center; justify-content: center; position: relative; margin-bottom: 1.5rem; }
        #preview { width: 100%; height: 100%; object-fit: contain; background-color: black; border-radius: 0.5rem; }
        #noPreview { position: absolute; text-align: center; color: var(--text-light); }
        #noPreview p { margin: 0.5rem 0 0 0; }
        .hidden { display: none !important; }
        .settings-container { background-color: #f9fafb; padding: 1rem; border-radius: 0.5rem; }
        .settings-grid { display: grid; grid-template-columns: 1fr; gap: 1.5rem; }
        @media (min-width: 768px) { .settings-grid { grid-template-columns: 1fr 1fr; } }
        .setting-group { display: flex; flex-direction: column; gap: 0.75rem; }
        .setting-item { display: flex; align-items: center; justify-content: space-between; font-size: 0.9rem; }
        .setting-item input[type="number"] { width: 4rem; padding: 0.25rem 0.5rem; border: 1px solid var(--border-color); border-radius: 0.25rem; }
        .setting-item input[type="range"] { width: 8rem; }
        .setting-item-row { display: flex; align-items: center; }
        .setting-item-row input[type="checkbox"] { margin-right: 0.5rem; }
        label { color: var(--text-color); }
        input[type="color"] { border: 1px solid var(--border-color); padding: 0; height: 2rem; width: 4rem; border-radius: 0.25rem; background: none; cursor: pointer; }
        select { padding: 0.25rem 0.5rem; border: 1px solid var(--border-color); border-radius: 0.25rem; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Screen Recorder</h1>
            <p>Minimalist design with intuitive controls</p>
        </header>

        <main>
            <div class="controls">
                <button id="startRecording" disabled>â–¶ Start Recording</button>
                <button id="stopRecording" disabled>â–  Stop Recording</button>
                <button id="downloadBtn" disabled>â‡© Export Video</button>
            </div>

            <div id="statusIndicator">
                <div id="statusIcon" class="loader"></div>
                <span id="statusText">Loading FFmpeg...</span>
            </div>

            <div class="preview-container">
                <video id="preview" class="hidden" controls></video>
                <div id="noPreview">
                    <span class="icon-symbol">ðŸŽ¬</span>
                    <p>Recording preview will appear here</p>
                </div>
            </div>

            <div class="settings-container">
                <h2>Settings</h2>
                <div class="settings-grid">
                    <div class="setting-group">
                        <h3>Zoom</h3>
                        <div class="setting-item">
                            <label for="zoomDuration">Duration (s)</label>
                            <input type="number" id="zoomDuration" value="2" min="1" max="10">
                        </div>
                        <div class="setting-item">
                            <label for="zoomScale">Scale</label>
                            <input type="range" id="zoomScale" min="1.1" max="4" step="0.1" value="2">
                            <span id="zoomScaleValue">2.0x</span>
                        </div>
                        <div class="setting-item-row">
                            <input type="checkbox" id="enableClickZoom" checked>
                            <label for="enableClickZoom">Zoom on click</label>
                        </div>
                        <div class="setting-item-row">
                            <input type="checkbox" id="enableTypeZoom" checked>
                            <label for="enableTypeZoom">Zoom on typing</label>
                        </div>
                    </div>
                    <div class="setting-group">
                        <h3>Background</h3>
                         <div class="setting-item">
                             <label for="bgType">Type</label>
                             <select id="bgType">
                                 <option value="none" selected>None</option>
                                 <option value="solid">Solid Color</option>
                                 <option value="gradient">Gradient</option>
                             </select>
                         </div>
                        <div id="solidBgSettings" class="hidden">
                             <div class="setting-item">
                                 <label for="bgColor">Color</label>
                                 <input type="color" id="bgColor" value="#FFFFFF">
                             </div>
                        </div>
                        <div id="gradientBgSettings" class="hidden">
                             <div class="setting-item">
                                 <label for="gradientStart">Start</label>
                                 <input type="color" id="gradientStart" value="#FFFFFF">
                             </div>
                             <div class="setting-item">
                                 <label for="gradientEnd">End</label>
                                 <input type="color" id="gradientEnd" value="#000000">
                             </div>
                             <div class="setting-item">
                                 <label for="gradientDirection">Direction</label>
                                 <select id="gradientDirection">
                                     <option value="horizontal">Horizontal</option>
                                     <option value="vertical">Vertical</option>
                                 </select>
                             </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script src="/ffmpeg/ffmpeg.js"></script>
    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpeg;

        // --- DOM Elements ---
        const startRecordingBtn = document.getElementById('startRecording');
        const stopRecordingBtn = document.getElementById('stopRecording');
        const downloadBtn = document.getElementById('downloadBtn');
        const previewVideo = document.getElementById('preview');
        const noPreview = document.getElementById('noPreview');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusIcon = document.getElementById('statusIcon');
        const statusText = document.getElementById('statusText');
        const zoomDurationInput = document.getElementById('zoomDuration');
        const zoomScaleInput = document.getElementById('zoomScale');
        const zoomScaleValue = document.getElementById('zoomScaleValue');
        const enableClickZoomCheckbox = document.getElementById('enableClickZoom');
        const enableTypeZoomCheckbox = document.getElementById('enableTypeZoom');
        const bgTypeSelect = document.getElementById('bgType');
        const solidBgSettings = document.getElementById('solidBgSettings');
        const gradientBgSettings = document.getElementById('gradientBgSettings');
        const bgColorInput = document.getElementById('bgColor');
        const gradientStartInput = document.getElementById('gradientStart');
        const gradientEndInput = document.getElementById('gradientEnd');
        const gradientDirectionSelect = document.getElementById('gradientDirection');

        // --- State Variables ---
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let zoomEvents = [];
        let recordingStartTime;
        let stream;
        let videoSettings = {};
        let processedVideoBlob = null;

        // --- Status Update Function ---
        function updateStatus(text, showIcon = true, iconType = 'loader') {
            statusText.textContent = text;
            statusIndicator.classList.remove('hidden');
            if (showIcon) {
                statusIcon.className = '';
                statusIcon.innerHTML = '';
                if (iconType === 'loader') {
                    statusIcon.classList.add('loader');
                } else if (iconType === 'pulse') {
                    statusIcon.classList.add('recording-pulse');
                } else if (iconType === 'ready') {
                    statusIcon.innerHTML = 'âœ…';
                } else if (iconType === 'error') {
                    statusIcon.innerHTML = 'âŒ';
                }
                statusIcon.classList.remove('hidden');
            } else {
                statusIcon.classList.add('hidden');
            }
        }

        // --- Main Application Logic ---
        async function init() {
            setupEventListeners();
            updateZoomScaleValue();
            handleBgTypeChange();
            await loadFFmpeg();
        }

        async function loadFFmpeg() {
            ffmpeg = new FFmpeg();
            ffmpeg.on('progress', ({ progress }) => {
                const percentage = Math.round(progress * 100);
                // Avoids showing 100% right before the "Ready" message.
                if (percentage < 100) {
                    updateStatus(`Loading FFmpeg... ${percentage}%`, true, 'loader');
                }
            });
            updateStatus('Loading FFmpeg... 0%', true, 'loader');
            try {
                await ffmpeg.load({
                    coreURL: '/ffmpeg/ffmpeg-core.js',
                    wasmURL: '/ffmpeg/ffmpeg-core.wasm',
                    workerURL: '/ffmpeg/ffmpeg-core.worker.js',
                });
            } catch (err) {
                 updateStatus('Failed to load FFmpeg. See console.', true, 'error');
                 console.error(err);
                 return;
            }
            updateStatus('Ready to record!', true, 'ready');
            startRecordingBtn.disabled = false;
        }

        function setupEventListeners() {
            startRecordingBtn.addEventListener('click', startRecording);
            stopRecordingBtn.addEventListener('click', stopRecording);
            downloadBtn.addEventListener('click', downloadRecording);
            zoomScaleInput.addEventListener('input', updateZoomScaleValue);
            bgTypeSelect.addEventListener('change', handleBgTypeChange);
        }

        function handleBgTypeChange() {
            const type = bgTypeSelect.value;
            solidBgSettings.classList.toggle('hidden', type !== 'solid' && type !== 'gradient');
            gradientBgSettings.classList.toggle('hidden', type !== 'gradient');
            if (type === 'solid') {
                 gradientBgSettings.classList.add('hidden');
                 solidBgSettings.classList.remove('hidden');
            } else if (type === 'gradient') {
                 solidBgSettings.classList.add('hidden');
                 gradientBgSettings.classList.remove('hidden');
            } else {
                 solidBgSettings.classList.add('hidden');
                 gradientBgSettings.classList.add('hidden');
            }
        }

        async function startRecording() {
            try {
                stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { mediaSource: 'screen', width: 1920, height: 1080, frameRate: 30 },
                    audio: false
                });

                const track = stream.getVideoTracks()[0];
                videoSettings = track.getSettings();

                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recordedChunks = [];
                zoomEvents = [];
                processedVideoBlob = null;
                recordingStartTime = performance.now();

                mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);

                const zoomEventHandler = (e) => recordZoomEvent(e);
                document.addEventListener('click', zoomEventHandler);
                document.addEventListener('keydown', zoomEventHandler);

                mediaRecorder.onstop = () => {
                     document.removeEventListener('click', zoomEventHandler);
                     document.removeEventListener('keydown', zoomEventHandler);
                     processVideoWithFFmpeg();
                };

                mediaRecorder.start();
                isRecording = true;

                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = false;
                downloadBtn.disabled = true;
                previewVideo.classList.add('hidden');
                noPreview.classList.remove('hidden');
                updateStatus('Recording...', true, 'pulse');

            } catch (err) {
                console.error('Error starting recording:', err);
                updateStatus('Permission denied. Please refresh and allow screen sharing.', true, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                stream.getTracks().forEach(track => track.stop());
                stopRecordingBtn.disabled = true;
                updateStatus('Processing video, this may take a moment...', true, 'loader');
            }
        }

        function recordZoomEvent(event) {
            if (!isRecording) return;
            if ((event.type === 'click' && !enableClickZoomCheckbox.checked) || (event.type === 'keydown' && !enableTypeZoomCheckbox.checked)) return;
            if (event.type === 'keydown' && (event.metaKey || event.ctrlKey || event.altKey)) return;

            // Scale screen coordinates by device pixel ratio to get physical pixels
            const x = event.screenX * window.devicePixelRatio;
            const y = event.screenY * window.devicePixelRatio;

            zoomEvents.push({
                timestamp: (performance.now() - recordingStartTime) / 1000,
                x,
                y,
                duration: parseFloat(zoomDurationInput.value),
                scale: parseFloat(zoomScaleInput.value)
            });
        }

        async function processVideoWithFFmpeg() {
            const needsZoom = zoomEvents.length > 0;
            const needsBg = bgTypeSelect.value !== 'none';

            if (!needsZoom && !needsBg) {
                console.log("No processing needed. Using original recording.");
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                displayProcessedVideo(blob);
                updateStatus('Video ready!', true, 'ready');
                return;
            }

            try {
                const inputFileName = 'input.webm';
                const outputFileName = 'output.mp4';
                await ffmpeg.writeFile(inputFileName, new Uint8Array(await new Blob(recordedChunks).arrayBuffer()));

                const { width, height, frameRate } = videoSettings;
                const args = ['-i', inputFileName];
                let filterComplex = [];
                let lastEventEnd = 0;
                let concatStreams = '';
                let streamCount = 0;

                let videoStream = '[0:v]';

                if (needsZoom) {
                    zoomEvents.forEach((event, i) => {
                        const start = event.timestamp;
                        if (start < lastEventEnd) return;

                        if (start > lastEventEnd) {
                            filterComplex.push(`[0:v]trim=start=${lastEventEnd}:end=${start},setpts=PTS-STARTPTS[v${streamCount}a]`);
                            concatStreams += `[v${streamCount}a]`;
                        }

                        const end = start + event.duration;
                        const zoompan = `zoompan=z='min(pzoom+0.01,${event.scale})':x='${event.x}-(iw/zoom/2)':y='${event.y}-(ih/zoom/2)':d=${Math.ceil(event.duration * frameRate)}:s=${width}x${height}`;
                        filterComplex.push(`[0:v]trim=start=${start}:end=${end},setpts=PTS-STARTPTS,${zoompan},setpts=PTS-STARTPTS[v${streamCount}b]`);
                        concatStreams += `[v${streamCount}b]`;

                        lastEventEnd = end;
                        streamCount++;
                    });

                    filterComplex.push(`[0:v]trim=start=${lastEventEnd},setpts=PTS-STARTPTS[v_end]`);
                    concatStreams += `[v_end]`;

                    const n = (concatStreams.match(/\[/g) || []).length;
                    filterComplex.push(`${concatStreams}concat=n=${n}:v=1:a=0[zoomed_v]`);
                    videoStream = '[zoomed_v]';
                }

                if (needsBg) {
                    let bgInput = '';
                    if (bgTypeSelect.value === 'solid') {
                        bgInput = `color=c=${bgColorInput.value}:s=${width}x${height}:d=999`;
                    } else {
                        const c0 = gradientStartInput.value;
                        const c1 = gradientEndInput.value;
                        const type = gradientDirectionSelect.value === 'vertical' ? 'y' : 'x';
                        bgInput = `gradient=c0=${c0}:c1=${c1}:s=${width}x${height}:type=${type}:d=999`;
                    }
                    args.push('-f', 'lavfi', '-i', bgInput);
                    filterComplex.push(`${videoStream}scale=w=min(iw,${width-40}):h=min(ih,${height-40}),pad=${width}:${height}:(ow-iw)/2:(oh-ih)/2[scaled_v]`);
                    filterComplex.push(`[1:v][scaled_v]overlay=x=0:y=0:shortest=1[final_v]`);
                    videoStream = '[final_v]';
                }

                if (filterComplex.length > 0) {
                    args.push('-filter_complex', filterComplex.join(';'));
                }

                args.push('-map', videoStream.includes('[') ? videoStream : `[${videoStream}]`);
                args.push('-c:v', 'libx264', '-preset', 'ultrafast', '-pix_fmt', 'yuv420p', outputFileName);

                await ffmpeg.exec(...args);

                const data = await ffmpeg.readFile(outputFileName);
                processedVideoBlob = new Blob([data.buffer], { type: 'video/mp4' });

                displayProcessedVideo(processedVideoBlob);
                updateStatus('Video ready!', true, 'ready');

            } catch (error) {
                console.error("Error during FFmpeg processing:", error);
                updateStatus('Error processing video. See console.', true, 'error');
                displayProcessedVideo(new Blob(recordedChunks, { type: 'video/webm' }));
            }
        }

        function displayProcessedVideo(blob) {
            processedVideoBlob = blob;
            previewVideo.src = URL.createObjectURL(blob);
            previewVideo.classList.remove('hidden');
            noPreview.classList.add('hidden');
            startRecordingBtn.disabled = false;
            downloadBtn.disabled = false;
        }

        function downloadRecording() {
            if (!processedVideoBlob) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(processedVideoBlob);
            a.download = `recording-${Date.now()}.${(processedVideoBlob.type.split('/')[1] || 'mp4')}`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function updateZoomScaleValue() {
            zoomScaleValue.textContent = `${parseFloat(zoomScaleInput.value).toFixed(1)}x`;
        }

        init();
    </script>
</body>
</html>
