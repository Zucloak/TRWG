<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Recorder | Minimalist Design</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .loader {
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .recording-pulse { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-light text-gray-800 mb-2">Screen Recorder</h1>
            <p class="text-gray-600">Minimalist design with intuitive controls</p>
        </header>

        <main class="max-w-4xl mx-auto">
            <div class="bg-white rounded-xl shadow-sm p-6 mb-6">
                <div class="flex flex-wrap justify-center gap-4 mb-6">
                    <button id="startRecording" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg flex items-center gap-2 transition-colors" disabled>
                        <i class="fas fa-circle"></i> Start Recording
                    </button>
                    <button id="stopRecording" disabled class="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg flex items-center gap-2 transition-colors opacity-50">
                        <i class="fas fa-stop"></i> Stop Recording
                    </button>
                    <button id="downloadBtn" disabled class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg flex items-center gap-2 transition-colors opacity-50">
                        <i class="fas fa-download"></i> Export Video
                    </button>
                </div>

                <div id="statusIndicator" class="flex items-center justify-center mb-6 text-gray-500">
                     <div id="statusIcon" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-6 w-6 mr-3"></div>
                    <span id="statusText" class="font-medium">Loading FFmpeg...</span>
                </div>

                <div class="mb-6">
                    <h2 class="text-lg font-medium text-gray-700 mb-3">Preview</h2>
                    <div class="bg-gray-100 rounded-lg overflow-hidden aspect-video flex items-center justify-center relative">
                        <video id="preview" class="w-full h-full object-contain bg-black hidden" controls></video>
                        <div id="noPreview" class="absolute inset-0 flex items-center justify-center text-gray-500">
                            <div class="text-center">
                                <i class="fas fa-video text-4xl mb-2"></i>
                                <p>Recording preview will appear here</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-50 rounded-lg p-4">
                    <h2 class="text-lg font-medium text-gray-700 mb-3">Settings</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-sm font-medium text-gray-600 mb-2">Zoom Settings</h3>
                            <div class="space-y-3">
                                <div class="flex items-center justify-between">
                                    <label for="zoomDuration" class="text-sm">Zoom Duration (seconds)</label>
                                    <input type="number" id="zoomDuration" value="2" min="1" max="10" class="border rounded px-2 py-1 w-16 text-sm">
                                </div>
                                <div class="flex items-center justify-between">
                                    <label for="zoomScale" class="text-sm">Zoom Scale</label>
                                    <input type="range" id="zoomScale" min="1.1" max="4" step="0.1" value="2" class="w-24">
                                    <span id="zoomScaleValue" class="text-sm w-8">2.0x</span>
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="enableClickZoom" checked class="mr-2">
                                    <label for="enableClickZoom">Zoom on click</label>
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="enableTypeZoom" checked class="mr-2">
                                    <label for="enableTypeZoom">Zoom on typing</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpeg;

        // --- DOM Elements ---
        const startRecordingBtn = document.getElementById('startRecording');
        const stopRecordingBtn = document.getElementById('stopRecording');
        const downloadBtn = document.getElementById('downloadBtn');
        const previewVideo = document.getElementById('preview');
        const noPreview = document.getElementById('noPreview');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusIcon = document.getElementById('statusIcon');
        const statusText = document.getElementById('statusText');
        
        const zoomDurationInput = document.getElementById('zoomDuration');
        const zoomScaleInput = document.getElementById('zoomScale');
        const zoomScaleValue = document.getElementById('zoomScaleValue');
        const enableClickZoomCheckbox = document.getElementById('enableClickZoom');
        const enableTypeZoomCheckbox = document.getElementById('enableTypeZoom');

        // --- State Variables ---
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let zoomEvents = [];
        let recordingStartTime;
        let stream;
        let processedVideoBlob = null;
        
        // --- Status Update Function ---
        function updateStatus(text, showIcon = true, iconType = 'loader') {
            statusText.textContent = text;
            statusIndicator.classList.remove('hidden');
            if (showIcon) {
                statusIcon.className = ''; // Clear classes
                if (iconType === 'loader') {
                    statusIcon.classList.add('loader', 'ease-linear', 'rounded-full', 'border-4', 'border-t-4', 'border-gray-200', 'h-6', 'w-6', 'mr-3');
                } else if (iconType === 'pulse') {
                    statusIcon.classList.add('recording-pulse', 'bg-red-600', 'w-3', 'h-3', 'rounded-full', 'mr-2');
                } else {
                     statusIcon.classList.add('fas', iconType, 'text-xl', 'mr-3');
                }
                statusIcon.classList.remove('hidden');
            } else {
                statusIcon.classList.add('hidden');
            }
        }

        // --- FFmpeg Caching Logic using IndexedDB ---
        const ffmpegCache = {
            DB_NAME: 'ffmpeg_cache_db',
            STORE_NAME: 'ffmpeg_core_store',
            db: null,
            initDB: function() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        db.createObjectStore(this.STORE_NAME);
                    };
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    request.onerror = (event) => {
                        console.error('IndexedDB error:', event.target.errorCode);
                        reject(event.target.error);
                    };
                });
            },
            getCore: function() {
                return new Promise(async (resolve, reject) => {
                    if (!this.db) await this.initDB();
                    const transaction = this.db.transaction([this.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.get('ffmpeg-core');
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            setCore: function(data) {
                return new Promise(async (resolve, reject) => {
                    if (!this.db) await this.initDB();
                    const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(this.STORE_NAME);
                    const request = store.put(data, 'ffmpeg-core');
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
        };

        // --- Main Application Logic ---
        async function init() {
            setupEventListeners();
            updateZoomScaleValue();
            await loadFFmpegWithCache();
        }
        
        async function loadFFmpegWithCache() {
            ffmpeg = new FFmpeg();
            const baseURL = "https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd"

            try {
                updateStatus('Checking cache for FFmpeg...');
                const coreFromCache = await ffmpegCache.getCore();
                if (coreFromCache) {
                    updateStatus('Loading FFmpeg from cache...');
                    await ffmpeg.load({
                        coreURL: URL.createObjectURL(new Blob([coreFromCache], { type: "application/javascript" })),
                        wasmURL: URL.createObjectURL(new Blob([await (await fetch(`${baseURL}/ffmpeg-core.wasm`)).arrayBuffer()], { type: "application/wasm" })),
                    });
                } else {
                     updateStatus('Fetching and caching FFmpeg...');
                    const coreResponse = await fetch(`${baseURL}/ffmpeg-core.js`);
                    const coreData = await coreResponse.arrayBuffer();
                    await ffmpegCache.setCore(coreData);
                    await ffmpeg.load({
                         coreURL: URL.createObjectURL(new Blob([coreData], { type: "application/javascript" })),
                         wasmURL: URL.createObjectURL(new Blob([await (await fetch(`${baseURL}/ffmpeg-core.wasm`)).arrayBuffer()], { type: "application/wasm" })),
                    });
                }
            } catch (err) {
                 updateStatus('Failed to load FFmpeg. See console.', true, 'fa-times-circle');
                 console.error(err);
                 return;
            }

            updateStatus('Ready to record!', true, 'fa-check-circle');
            startRecordingBtn.disabled = false;
        }

        function setupEventListeners() {
            startRecordingBtn.addEventListener('click', startRecording);
            stopRecordingBtn.addEventListener('click', stopRecording);
            downloadBtn.addEventListener('click', downloadRecording);
            zoomScaleInput.addEventListener('input', updateZoomScaleValue);
        }

        async function startRecording() {
            try {
                stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { mediaSource: 'screen', width: 1920, height: 1080, frameRate: 30 },
                    audio: false
                });

                const trackSettings = stream.getVideoTracks()[0].getSettings();
                const screenWidth = trackSettings.width;
                const screenHeight = trackSettings.height;

                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recordedChunks = [];
                zoomEvents = [];
                processedVideoBlob = null;
                recordingStartTime = performance.now();
                
                mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
                mediaRecorder.onstop = () => processVideoWithFFmpeg(screenWidth, screenHeight);
                
                const zoomEventHandler = (e) => recordZoomEvent(e);
                document.addEventListener('click', zoomEventHandler);
                document.addEventListener('keydown', zoomEventHandler);
                mediaRecorder.onstop = () => {
                     document.removeEventListener('click', zoomEventHandler);
                     document.removeEventListener('keydown', zoomEventHandler);
                     processVideoWithFFmpeg(screenWidth, screenHeight);
                }

                mediaRecorder.start();
                isRecording = true;
                
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = false;
                downloadBtn.disabled = true;
                stopRecordingBtn.classList.remove('opacity-50');
                downloadBtn.classList.add('opacity-50');
                previewVideo.classList.add('hidden');
                noPreview.classList.remove('hidden');
                updateStatus('Recording...', true, 'pulse');
                
            } catch (err) {
                console.error('Error starting recording:', err);
                updateStatus('Permission denied. Please refresh and allow screen sharing.', true, 'fa-exclamation-triangle');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                stream.getTracks().forEach(track => track.stop());
                stopRecordingBtn.disabled = true;
                stopRecordingBtn.classList.add('opacity-50');
                updateStatus('Processing video, this may take a moment...', true, 'loader');
            }
        }

        function recordZoomEvent(event) {
            if (!isRecording) return;
            if ((event.type === 'click' && !enableClickZoomCheckbox.checked) || (event.type === 'keydown' && !enableTypeZoomCheckbox.checked)) return;
            if (event.type === 'keydown' && (event.metaKey || event.ctrlKey || event.altKey)) return;

            zoomEvents.push({
                timestamp: (performance.now() - recordingStartTime) / 1000,
                x: event.screenX, y: event.screenY,
                duration: parseFloat(zoomDurationInput.value),
                scale: parseFloat(zoomScaleInput.value)
            });
        }
        
        async function processVideoWithFFmpeg(screenWidth, screenHeight) {
            if (zoomEvents.length === 0) {
                console.log("No zoom events. Finalizing video without FFmpeg.");
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                displayProcessedVideo(blob);
                updateStatus('Video ready!', true, 'fa-check-circle');
                return;
            }

            try {
                const inputFileName = 'input.webm';
                const outputFileName = 'output.mp4';
                await ffmpeg.writeFile(inputFileName, new Uint8Array(await new Blob(recordedChunks).arrayBuffer()));
                
                // --- Build FFmpeg zoompan filter string ---
                const easeDuration = 0.4; // Seconds for easing in/out
                let filter_chains = [];
                let last_event_end = 0;

                zoomEvents.forEach((event, i) => {
                    const start = event.timestamp;
                    const end = start + event.duration;
                    const x = event.x;
                    const y = event.y;
                    const scale = event.scale;

                    if (start < last_event_end) return; // Skip overlapping events

                    // 1. Segment before the zoom
                    filter_chains.push(`[0:v]trim=start=${last_event_end}:end=${start},setpts=PTS-STARTPTS[v${i}a]`);
                    
                    // 2. The zoom effect itself
                    const zoompan_filter = `trim=${start}:${end},setpts=PTS-STARTPTS,zoompan=z='min(max(zoom,pzoom)+0.0015*${scale}, ${scale})':x='${x}-(iw/zoom/2)':y='${y}-(ih/zoom/2)':d=1:s=${screenWidth}x${screenHeight},trim=duration=${event.duration},setpts=PTS-STARTPTS[v${i}b]`;
                    filter_chains.push(`[0:v]${zoompan_filter}`);

                    last_event_end = end;
                });
                
                // 3. Segment after the last zoom
                filter_chains.push(`[0:v]trim=start=${last_event_end},setpts=PTS-STARTPTS[v_end]`);
                
                const concat_inputs = zoomEvents.map((_, i) => `[v${i}a][v${i}b]`).join('') + '[v_end]';
                const filter_complex = `${filter_chains.join(';')}; ${concat_inputs}concat=n=${zoomEvents.length * 2 + 1}:v=1:a=0[v]`;

                await ffmpeg.exec(['-i', inputFileName, '-filter_complex', filter_complex, '-map', '[v]', '-c:v', 'libx264', '-preset', 'ultrafast', '-pix_fmt', 'yuv420p', outputFileName]);
                
                const data = await ffmpeg.readFile(outputFileName);
                processedVideoBlob = new Blob([data.buffer], { type: 'video/mp4' });
                
                displayProcessedVideo(processedVideoBlob);
                updateStatus('Video ready!', true, 'fa-check-circle');

            } catch (error) {
                console.error("Error during FFmpeg processing:", error);
                updateStatus('Error processing video. See console.', true, 'fa-times-circle');
                displayProcessedVideo(new Blob(recordedChunks, { type: 'video/webm' }));
            }
        }
        
        function displayProcessedVideo(blob) {
            processedVideoBlob = blob;
            previewVideo.src = URL.createObjectURL(processedVideoBlob);
            previewVideo.classList.remove('hidden');
            noPreview.classList.add('hidden');
            startRecordingBtn.disabled = false;
            downloadBtn.disabled = false;
            downloadBtn.classList.remove('opacity-50');
        }

        function downloadRecording() {
            if (!processedVideoBlob) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(processedVideoBlob);
            a.download = `recording-${Date.now()}.${processedVideoBlob.type.split('/')[1]}`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function updateZoomScaleValue() {
            zoomScaleValue.textContent = `${parseFloat(zoomScaleInput.value).toFixed(1)}x`;
        }

        init();
    </script>
</body>
</html>
